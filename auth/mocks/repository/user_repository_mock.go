// Code generated by MockGen. DO NOT EDIT.
// Source: ../internal/domain/repository/user_repository.go
//
// Generated by this command:
//
//	mockgen -source=../internal/domain/repository/user_repository.go -destination=repository/user_repository_mock.go -package=repository
//

// Package repository is a generated GoMock package.
package repository

import (
	reflect "reflect"

	domain "github.com/klimenkokayot/avito-go/services/auth/internal/domain/repository"
	gomock "go.uber.org/mock/gomock"
)

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
	ctrl     *gomock.Controller
	recorder *MockUserRepositoryMockRecorder
	isgomock struct{}
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
	mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository {
	mock := &MockUserRepository{ctrl: ctrl}
	mock.recorder = &MockUserRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockUserRepository) Add(login, secret string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", login, secret)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockUserRepositoryMockRecorder) Add(login, secret any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockUserRepository)(nil).Add), login, secret)
}

// Check mocks base method.
func (m *MockUserRepository) Check(login, pass string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Check", login, pass)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Check indicates an expected call of Check.
func (mr *MockUserRepositoryMockRecorder) Check(login, pass any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockUserRepository)(nil).Check), login, pass)
}

// ExistByLogin mocks base method.
func (m *MockUserRepository) ExistByLogin(login string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistByLogin", login)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExistByLogin indicates an expected call of ExistByLogin.
func (mr *MockUserRepositoryMockRecorder) ExistByLogin(login any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistByLogin", reflect.TypeOf((*MockUserRepository)(nil).ExistByLogin), login)
}

// FindByLogin mocks base method.
func (m *MockUserRepository) FindByLogin(login string) (*domain.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByLogin", login)
	ret0, _ := ret[0].(*domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByLogin indicates an expected call of FindByLogin.
func (mr *MockUserRepositoryMockRecorder) FindByLogin(login any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByLogin", reflect.TypeOf((*MockUserRepository)(nil).FindByLogin), login)
}
